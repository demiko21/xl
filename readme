1. How code runs and how stack manages variables
When a function is called, a stack frame is created.
This frame stores local variables, return address, and temporary values.
When the function finishes, its frame is removed (popped), and all its local variables disappear automatically.
The stack is fast and works in LIFO order.
2. What variables are stored in the heap and why
Heap stores dynamic objects created at runtime (e.g., Python lists, dicts, class objects).
They go to the heap because their size or lifetime is not known in advance.
Heap objects stay alive until no references point to them (GC cleans them).
4. Eden space 
Eden is part of the young generation in a garbage collector.
New objects are created in Eden.
Most die quickly, so Eden is cleaned often using fast “minor GC.”
5. Mark-and-sweep algorithm 
Mark: starting from root references, mark all reachable objects.
Sweep: go through memory and delete all unmarked objects.
This frees memory used by unreachable objects
6.
# simple parser + executor
def run(code):
    env = {}
    lines = [l.strip() for l in code.split(";") if l.strip()]
    for line in lines:
        if line.startswith("print"):
            var = line.split()[1]
            print(env[var])
        else:
            name, val = line.split("=")
            env[name.strip()] = int(val.strip())

# example program
prog = """
x = 10;
y = 20;
print x;
print y;
"""
run(prog)

