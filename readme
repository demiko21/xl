Question 1 – Concept Explanation a) Checks: Syntax analysis checks the grammatical structure (e.g., matching braces). Semantic analysis checks the logical meaning (e.g., type consistency). b) Errors: Syntax detects a missing semicolon; Semantic detects a type mismatch (e.g., adding a string to an integer). c) Why separate: Parsing uses Context-Free Grammars which cannot track context-sensitive info, such as whether a variable was declared before use.

Question 2 – Error Detection & Responsibility a) Missing semicolon: Syntax Analysis; it violates the grammar rules of the language structure. b) Use of an undeclared variable: Semantic Analysis; requires checking the symbol table for existence. c) Type mismatch in assignment: Semantic Analysis; requires comparing the data types of the source and destination. d) Infinite loop: Generally not detected; this is a logical issue that is often undecidable (Halting Problem). e) Division by zero (constants): Semantic Analysis/Optimization; the compiler evaluates constant expressions and flags illegal math.

Question 3 – Design Question a) Use a Stack of Hash Tables for the symbol table. b) Push a new hash table onto the stack when entering a new function or block (nested scope). c) Resolve names by searching from the top (inner) table downward to the bottom (global) table. d) Pop the top table when exiting a block to automatically handle scope expiration.

Question 4 – Comparison Question a) Lexical Scoping: Resolution is based on where the code is written (static structure). Binding is decided at compile time. Advantage: Code is predictable and readable. Disadvantage: Less flexible for runtime environment changes. b) Dynamic Scoping: Resolution is based on the calling sequence (the stack). Binding is decided at runtime. Advantage: Easy to pass parameters implicitly. Disadvantage: Very difficult to debug and trace.

Question 5 – Optimization Safety a) Meaning: Transformations must be "semantics-preserving." An optimization is unsafe if it changes the output or causes a crash that wouldn't have happened (e.g., moving a calculation before its guard check). b) Dataflow Analysis: It maps how values move through the code to ensure that reordering doesn't break dependencies or logic. c) Unsafe Example: Removing "dead code" that actually performs a necessary side effect, like an I/O operation or hardware trigger.

Question 6 – Intermediate Representation Choice a) Why IR: It allows the compiler to support multiple source languages and multiple target CPUs without rewriting the entire system for every combination. b) Three-address code: It is simple and linear, making it easy to perform instruction scheduling and register allocation. c) SSA (Static Single Assignment): Every variable is assigned only once, which significantly simplifies and speeds up dataflow optimizations.

Question 7 – Runtime System & Calling Conventions a) Storage: A stack frame stores return addresses, function parameters, local variables, and saved registers. b) Prologue/Epilogue: The prologue sets up the frame (allocates space); the epilogue cleans it up (restores registers and returns control). c) Registers: Caller-saved registers are backed up by the calling function; Callee-saved registers must be preserved/restored by the function being called.

Question 8 – Virtual Machines & JIT Compilation a) VM Types: Stack-based VMs use a stack for operations (simple, compact); Register-based VMs use virtual registers (faster, closer to real hardware). b) JIT Definition: Just-In-Time compilation converts bytecode into native machine code at runtime. c) Performance: JIT outperforms interpretation because the code runs directly on the CPU as native instructions, skipping the overhead of an interpreter loop.
